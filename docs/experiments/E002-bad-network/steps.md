---
id: E002
type: steps
---
## Предварительные условия

- Между сервером и клиентом установлено и проверено USB/IP‑соединение.
    
- USB‑устройство успешно экспортируется сервером и доступно клиенту.
    
- На клиенте установлены `fio`, `tc`, `iproute2`.
    
- Пользователь имеет права `root` или `sudo`.
    
---

## Шаги

### 1. Подготовка сервера USB/IP

1. Запуск демона USB/IP:
    

```bash
usbipd -D
```

2. Проверка доступных USB‑устройств:
    

```bash
usbip list -l
```

3. Экспорт выбранного USB‑устройства:
    

```bash
usbip bind -b <busid>
```

---

### 2. Подготовка клиента USB/IP

1. Загрузка модуля виртуального USB‑хоста:
    

```bash
modprobe vhci_hcd
```

2. Подключение удалённого USB‑устройства:
    

```bash
usbip attach -r <server_ip> -b <busid>
```

3. Проверка появления блочного устройства:
    

```bash
lsblk
```

4. Монтирование устройства:
    

```bash
mount /dev/sdX /mnt/usb
```

---

### 3. Проверка базовой работоспособности

Перед началом эксперимента необходимо убедиться, что устройство доступно для записи:

```bash
touch /mnt/usb/testfile
sync
```

---

### 4. Применение сетевой деградации (tc netem)

Сетевые условия эмулируются **на стороне клиента**.

Для каждого профиля задержки выполняется:

```bash
tc qdisc add dev <iface> root netem delay <N>ms limit 1000
```

Где `<N>` принимает значения:

- `0 ms` (baseline)
    
- `20 ms`
    
- `80 ms`
    
- `200 ms`
    

Проверка состояния очереди:

```bash
tc -s qdisc show dev <iface>
```

---

### 5. Генерация I/O‑нагрузки

Для каждого сетевого профиля выполняется одинаковый набор fio‑тестов.

Параметры fio:

- `direct=1`
    
- `iodepth=1`
    
- `numjobs=1`
    
- `time_based=1`
    
- `runtime=15s`
    
- размер тестового файла: `256M`
    

Набор нагрузок:

1. `seq_write` — последовательная запись (1 MB)
    
2. `seq_read` — последовательное чтение (1 MB)
    
3. `rand_read_4k` — случайное чтение (4 KB)
    
4. `rand_write_4k` — случайная запись (4 KB)
    

Каждый тест сохраняет результат в формате JSON.

---

### 6. Сбор системных данных

Во время или сразу после каждого прогона фиксируются:

- состояние очередей:
    

```bash
tc -s qdisc show dev <iface>
```

- TCP‑состояние:
    

```bash
ss -tin
nstat
```

- системная информация и preflight‑данные:
    

```bash
uname -a
mount | grep usb
```

---

### 7. Очистка сетевых условий

После завершения прогона профиля задержки:

```bash
tc qdisc del dev <iface> root
```

Проверка возврата к baseline‑состоянию:

```bash
tc qdisc show dev <iface>
```

---

## Ожидаемый результат (чек‑лист)

-  USB‑устройство корректно подключено и смонтировано
    
-  Для каждого профиля задержки выполнены все fio‑нагрузки
    
-  fio завершился без фатальных ошибок
    
-  JSON‑артефакты сохранены и валидны
    
-  Сетевая деградация корректно применялась и снималась
    
-  При росте задержки наблюдается деградация I/O‑метрик